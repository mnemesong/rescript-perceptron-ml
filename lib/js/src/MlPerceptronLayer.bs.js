// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var InvalidCountOfLayerElements = /* @__PURE__ */Caml_exceptions.create("MlPerceptronLayer.InvalidCountOfLayerElements");

function MakePerceptronLayerLimitedArr(LayerCount) {
  var layerToArr = (function (vals) {
    return vals;
  });
  var arrToLayer = function (arr) {
    var convert = (function (vals) {
      return vals;
    });
    if (arr.length === LayerCount.layerCount) {
      return {
              TAG: /* Ok */0,
              _0: convert(arr)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: {
                RE_EXN_ID: InvalidCountOfLayerElements
              }
            };
    }
  };
  var init = function (initor) {
    var il = (function (initor, cnt) {
      let result = [];
      for(let i = 0; i < cnt; i++) {
        result.push(initor(i));
      }
      return result;
    });
    return il(initor, LayerCount.layerCount);
  };
  return {
          layerToArr: layerToArr,
          arrToLayer: arrToLayer,
          init: init
        };
}

var WeightsLayerHasNoZeroElement = /* @__PURE__ */Caml_exceptions.create("MlPerceptronLayer.WeightsLayerHasNoZeroElement");

function MakePerceptronLayersCross(Layer1, Layer2, F, Err) {
  var input = function (inp) {
    var arr1 = Curry._1(Layer1.layerToArr, inp);
    return Curry._1(Layer1.arrToLayer, Belt_Array.map(arr1, (function (v) {
                      return {
                              solve: Curry._1(F.solve, v),
                              derivative: Curry._1(F.derivative, v)
                            };
                    })));
  };
  var solve = function (l1, w) {
    var layer1Arr = Curry._1(Layer1.layerToArr, l1);
    var weightsArr = Belt_Array.map(Curry._1(Layer1.layerToArr, w), (function (a) {
            return Curry._1(Layer2.layerToArr, a);
          }));
    var tmp;
    var exit = 0;
    var x;
    try {
      x = Belt_Array.mapWithIndex(Belt_Option.getExn(Belt_Array.get(weightsArr, 0)), (function (n, param) {
              var valsWeighted = Belt_Array.mapWithIndex(layer1Arr, (function (i, v) {
                      return v.solve * Belt_Option.getExn(Belt_Array.get(Belt_Option.getExn(Belt_Array.get(weightsArr, i)), n));
                    }));
              return Belt_Array.reduce(valsWeighted, 0.0, (function (acc, el) {
                            return acc + el;
                          }));
            }));
      exit = 1;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      tmp = {
        TAG: /* Error */1,
        _0: e
      };
    }
    if (exit === 1) {
      tmp = {
        TAG: /* Ok */0,
        _0: x
      };
    }
    return Belt_Result.flatMap(Belt_Result.map(tmp, (function (r) {
                      return Belt_Array.map(r, (function (v) {
                                    return {
                                            solve: Curry._1(F.solve, v),
                                            derivative: Curry._1(F.derivative, v)
                                          };
                                  }));
                    })), (function (r) {
                  return Curry._1(Layer2.arrToLayer, r);
                }));
  };
  var findError = function (vals, nominals) {
    try {
      var valsArr = Curry._1(Layer2.layerToArr, vals);
      return Curry._1(Layer2.arrToLayer, Belt_Array.mapWithIndex(Curry._1(Layer2.layerToArr, nominals), (function (i, n) {
                        return Curry._2(Err.errMetricDerivative, n, Belt_Option.getExn(Belt_Array.get(valsArr, i)).solve);
                      })));
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      return {
              TAG: /* Error */1,
              _0: e
            };
    }
  };
  var backpropagadeError = function (l1Vals, l2Errs, weights) {
    var weightsArr = Belt_Array.map(Curry._1(Layer1.layerToArr, weights), (function (w) {
            return Curry._1(Layer2.layerToArr, w);
          }));
    try {
      return Curry._1(Layer1.arrToLayer, Belt_Array.mapWithIndex(Curry._1(Layer1.layerToArr, l1Vals), (function (i, l1v) {
                        var errSum = Belt_Array.reduce(Belt_Array.mapWithIndex(Curry._1(Layer2.layerToArr, l2Errs), (function (j, el) {
                                    return [
                                            Curry._1(Err.errToFloat, el),
                                            j
                                          ];
                                  })), 0.0, (function (acc, el) {
                                return acc + el[0] * Belt_Option.getExn(Belt_Array.get(Belt_Option.getExn(Belt_Array.get(weightsArr, i)), el[1]));
                              }));
                        return Curry._1(Err.floatToErr, errSum * l1v.derivative);
                      })));
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      return {
              TAG: /* Error */1,
              _0: e
            };
    }
  };
  var weightCorrection = function (l1Vals, l2Errs, weights, learnCoeff) {
    var l1ValsArr = Curry._1(Layer1.layerToArr, l1Vals);
    var l2ErrArr = Curry._1(Layer2.layerToArr, l2Errs);
    var weightsArr = Belt_Array.map(Curry._1(Layer1.layerToArr, weights), (function (w) {
            return Curry._1(Layer2.layerToArr, w);
          }));
    try {
      return Curry._1(Layer1.arrToLayer, Belt_Array.map(Belt_Array.mapWithIndex(weightsArr, (function (i, wi) {
                            return Belt_Array.mapWithIndex(wi, (function (j, wj) {
                                          var solve = Belt_Option.getExn(Belt_Array.get(l1ValsArr, i)).solve;
                                          var err = Curry._1(Err.errToFloat, Belt_Option.getExn(Belt_Array.get(l2ErrArr, j)));
                                          return wj - learnCoeff * solve * err;
                                        }));
                          })), (function (nw) {
                        return Belt_Result.getExn(Curry._1(Layer2.arrToLayer, nw));
                      })));
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      return {
              TAG: /* Error */1,
              _0: e
            };
    }
  };
  var init = function (initor) {
    return Curry._1(Layer1.init, (function (i) {
                  return Curry._1(Layer2.init, (function (j) {
                                return Curry._2(initor, i, j);
                              }));
                }));
  };
  return {
          input: input,
          solve: solve,
          findError: findError,
          backpropagadeError: backpropagadeError,
          weightCorrection: weightCorrection,
          init: init
        };
}

exports.InvalidCountOfLayerElements = InvalidCountOfLayerElements;
exports.MakePerceptronLayerLimitedArr = MakePerceptronLayerLimitedArr;
exports.WeightsLayerHasNoZeroElement = WeightsLayerHasNoZeroElement;
exports.MakePerceptronLayersCross = MakePerceptronLayersCross;
/* No side effect */
